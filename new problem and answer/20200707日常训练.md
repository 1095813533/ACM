#A. Shuffle Hashing<br>
Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems.<br>
Polycarp decided to store the hash of the password, generated by the following algorithm:<br>
take the password p, consisting of lowercase Latin letters, and shuffle the letters randomly in it to obtain p′ (p′ can still be equal to p);<br>
generate two random strings, consisting of lowercase Latin letters, s1 and s2 (any of these strings can be empty);<br>
the resulting hash h=s1+p′+s2, where addition is string concatenation.<br>
For example, let the password p= "abacaba". Then p′ can be equal to "aabcaab". Random strings s1= "zyx" and s2= "kjh". Then h= "zyxaabcaabkjh".<br>
Note that no letters could be deleted or added to p to obtain p′, only the order could be changed.<br>
Now Polycarp asks you to help him to implement the password check module. Given the password p and the hash h, check that h can be the hash for the password p.<br>
Your program should answer t independent test cases.<br>
Input<br>
The first line contains one integer t (1≤t≤100) — the number of test cases.<br>
The first line of each test case contains a non-empty string p, consisting of lowercase Latin letters. The length of p does not exceed 100.<br>
The second line of each test case contains a non-empty string h, consisting of lowercase Latin letters. The length of h does not exceed 100.<br>
Output<br>
For each test case print the answer to it — "YES" if the given hash h could be obtained from the given password p or "NO" otherwise.<br>
Example<br>
input<br>
```
5
abacaba
zyxaabcaabkjh
onetwothree
threetwoone
one
zzonneyy
one
none
twenty
ten
```
out
```
YES
YES
NO
YES
NO
```
Note<br>
The first test case is explained in the statement.<br>
In the second test case both s1 and s2 are empty and p′= "threetwoone" is p shuffled.<br>
In the third test case the hash could not be obtained from the password.<br>
In the fourth test case s1= "n", s2 is empty and p′= "one" is p shuffled (even thought it stayed the same).<br>
In the fifth test case the hash could not be obtained from the password.<br>
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
typedef long long ll;
char s1[105],s2[105];
int main()
{
    int t;
    cin >> t;
    getchar();
    while(t--){
        gets(s1);
        gets(s2);
        int len_1, len_2;
        len_1 = strlen(s1);
        len_2 = strlen(s2);
        sort(s1, s1+len_1);
        if(len_1 > len_2){
            printf("NO\n");
            continue;
        }
        bool flag;
        for(int i = 0; i < len_2 - len_1 + 1; i++)
        {
            flag = 1;
            char t[105];
            strcpy(t, s2);
            sort(t + i, t + i + len_1);
            for(int j = 0;j < len_1; j++){
                if(s1[j] != t[i+j]){
                    flag = 0;
                    break;
                }
            }
            if(flag)
                break;
        }
        if(flag)
			printf("YES\n");
        else
			printf("NO\n");
    }
    return 0;
}
```

#B. A and B
You are given two integers a and b. You can perform a sequence of operations: during the first operation you choose one of these numbers and increase it by 1; during the second operation you choose one of these numbers and increase it by 2, and so on. You choose the number of these operations yourself.<br>
For example, if a=1 and b=3, you can perform the following sequence of three operations:<br>
add 1 to a, then a=2 and b=3;<br>
add 2 to b, then a=2 and b=5;<br>
add 3 to a, then a=5 and b=5.<br>
Calculate the minimum number of operations required to make a and b equal.<br>
Input<br>
The first line contains one integer t (1≤t≤100) — the number of test cases.<br>
The only line of each test case contains two integers a and b (1≤a,b≤109).<br>
Output<br>
For each test case print one integer — the minimum numbers of operations required to make a and b equal.<br>
Example<br>
input<br>
```
3
1 3
11 11
30 20
```
output<br>
```
3
0
4
```
Note<br>
First test case considered in the statement.<br>
In the second test case integers a and b are already equal, so you don't need to perform any operations.<br>
In the third test case you have to apply the first, the second, the third and the fourth operation to b (b turns into 20+1+2+3+4=30).<br>
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
typedef long long ll;
int t,a,b;
int main()
{
	cin>>t;
	while(t--)
	{
		cin >> a >> b;
		if(a < b) swap(a,b);
		if(a == b)
		{
			printf("0\n");
			continue;
		}
		int ans = 1;
		while(1)
		{
			ll sum = ans * (ans + 1) / 2;
			if(sum >= (a - b)&& sum % 2 == (a - b) % 2) break;
			ans++;
		}
		cout << ans << endl;
	}
}
```